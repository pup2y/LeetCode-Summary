# 2.二分查找

## 01.基础
* 前提：输入范围必须已按照规则**排序**
* 时间复杂度 O(logN)
* 库函数lower_bound  返回>=target的迭代器
### <1> 闭区间写法    [left,right]
```cpp
int left = 0, right = vector.size()-1; // 闭区间的范围控制在可取到的值
while(left <= right){ 
  int mid = left + (right - left)/2; // 避免int型数值溢出
  // 注：闭区间不能写成right/left = mid，会导致死循环。
  if(vector[mid] < target)
    left = mid + 1;     // [mid+1,right]
  else
    right = mid - 1;   //  [left,mid-1]
}
return left;
```
### <2> 半开半闭区间写法    [left,right)
```cpp
int left = 0, right = vector.size(); // 开区间则控制在不可取到的值。
while(left < right){ 
  int mid = left + (right - left)/2; // 避免int型数值溢出
  // 注：闭区间不能写成right/left = mid，会导致死循环。
  if(vector[mid] < target)
    left = mid + 1;     // [mid+1,right)
  else
    right = mid ;   //  [left,mid)
}
return left;
```
### <3> 开区间写法    (left,right)
```cpp
int left = -1, right = vector.size(); // 开区间则控制在不可取到的值。
while(left+1 < right){ 
  int mid = left + (right - left)/2; // 避免int型数值溢出
  // 注：闭区间不能写成right/left = mid，会导致死循环。
  if(vector[mid] < target)
    left = mid ;     // (mid,right)
  else
    right = mid ;   //  (left,mid)
}
return left;
```
* upper_bound函数  (>target) 需要将判定条件更改为 **vector[mid] <= target**
* last_less_than函数 (<target) => (>=target)-1 在函数lower_bound的基础上返回**left-1** \
即 `last_less_than(target) = lower_bound(target) - 1`
* last_less_or_equal函数 (<=target) => (>target)-1 在函数upper_bound的基础上返回**left-1** \
即 `last_less_or_equal(target) = upper_bound(target) - 1`
## 02.二分答案
### <1>求最小、最大
一般题目中有**至多，最多**的要求
### <2>求最短/最小子数组 
一般题目中有**至少，最小**的要求
```cpp
int ans = 0, statistic = 0; //初始化答案，统计量
int left =0, right = 0; 
for(; right < 容器.size();right++){ //进入循环窗口
  update(statistic,容器[right]); //引入索引为right的元素 更新统计量状态
  while(statistic){             //维护统计量状态
    update(statistic,容器[left]); //除去索引为left的元素  更新统计量状态
    left++;    //左端点自增
  }
  //  while循环内/外均可更新答案，写法不统一
  update(ans);   //更新答案
}
return ans;
```
### <3>求子数组个数 
* (1) 越长越合法 \
一般要写 `ans += left`。\
滑动窗口的内层循环结束时，右端点固定在 right，左端点在 0,1,2,…,left−1 的所有子数组（子串）都是合法的，共计 left 个。\
* (2) 越长越合法 \
一般要写 `ans += right-left+1`。\
滑动窗口的内层循环结束时，右端点固定在 right，左端点在 left,left+1,…,right 的所有子数组（子串）都是合法的，共计 right−left+1 个。\
```cpp
int ans = 0, statistic = 0; //初始化答案，统计量
int left =0, right = 0; 
for(; right < 容器.size();right++){ //进入循环窗口
  update(statistic,容器[right]); //引入索引为right的元素 更新统计量状态
  while(statistic){             //维护统计量状态
    update(statistic,容器[left]); //除去索引为left的元素  更新统计量状态
    left++;    //左端点自增
  }
  update(ans);
  //越长越合法  ans += left;
  //越短越合法  ans += right-left+1;
}
return ans;
```
* (3) 恰好型滑动窗口 \
「恰好」可以拆分成两个「越长越合法」的滑窗问题，也可以拆分为两个「越短越合法」的滑窗问题，也可以用三指针滑动窗口解决（right，left1，left2）。\
例如：恰好元素和 ≥k 的子数组个数，减去元素和 ≥k+1(>k) 的子数组个数，从而可以把滑窗逻辑封装成一个函数 f，然后用 f(k) - f(k + 1) 计算。

## 03.单序列双指针
### <1>相向双指针 
两个指针**left=0, right=n−1**，从数组的两端开始，向中间移动，这叫相向双指针。而滑动窗口问题相当于同向双指针。
### <2>同向双指针 
两个指针的移动方向相同（都向右，或者都向左）。
### <3>背向双指针 
两个指针从数组中的同一个位置出发，一个向左，另一个向右，背向移动。
### <4>原地修改

## 04.双序列双指针
### <1>双指针
### <2>判断子序列
   
## 05.三指针

## 06.分组循环
适用场景：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。\
核心思想：\
* 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案）。
* 内层循环负责遍历组，依据统计量状态跳出循环。
```cpp
int ans = 0, index = 0, statistic = 0; //初始化答案，索引值，统计量
while(index < 容器.size()){ 
  int start = index; //记录开始位置
  while(statistic){  //维护统计量状态
    update(statistic,容器[index]); //除去索引为left的元素  更新统计量状态
    index++;    //左端点自增
  }
  update(ans);
  index++;
}
return ans;
```

---
### 更新记录
- 2025-03-14: 创建初始报告
- 2025-03-19: 更新内容描述
```

